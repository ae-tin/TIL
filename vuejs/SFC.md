# SingleFileComponent

## Component

> 재사용 가능한 코드 블록

- 컴포넌트는 웹 페이지를 구성하느 재사용 가능한  UI로, 마치 레고블럭 같은 독립적인 기능을 가짐

- 레고블럭들을 조립하여 페이지를 만들기 때문에 코드 재사용성이 높아지고 유지보수가 쉬워짐

### Component 특징

-  자연스럽게 애플리캐이션은 중첩된  Component의 트리 형태로 구성됨

## Single-File Components

> 컴포넌트의 템플릿, 로직 및 스타일을 하나의 파일로 묶어낸 특수한 파일 형식

- SFC는 하나의 .vue 파일 안에 컴포넌트의 html, js, css코드를 모두 담는 vue의 개발 방식

- 화면 구조를 담당하는 template, 로직을 담당하는 script, 스타일을 담당하는 style 세부분으로 나뉨

- 일반적으로 template - script - style 순서로 작성



```markdown
<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>  


```



### <template> 블록

- 각 .vue 파일은 최상위 template 블록을 하나만 포함 할 수 있음



### <script setup> 블록

- 각 파일은 script setup 블록을 하나만 포함할 수 있음

- 일반 script 제외

- 컴포넌트의 setup 함수로 사용되며 컴포넌트의 각 인스턴스에 대해 실행
  
  - 변수 및 함수는 동일한 컴포넌트의 템플릿에서 자동으로 사용 가능



### <style scoped>  블록

- vue 파일에는 여러 style 태그가 포함될 수 있음

- scoped 가 지정되면 css는 현재 컴포넌트에만 적용됨



### 컴포넌트 사용하기

- [https://play.vuejs.org/]() 에서 vue 컴포넌트 코드 작성 및 미리보기

- vue sfc는 일반적인 방법으로 실행할 수 없으며 컴파일러를 통해 컴파일된 후 빌드 되어야 함
  
  - 실제 프로젝트에서는 vite와 같은 공식 빌드 도구를 사용



## Vite - SFC build tool

> 프론트 엔드 개발 도구로써 빠른 개발 환경을 위한 빌드 도구와 개발 서버를 제공

- 프론트엔드 개발을 위한 빌드 도구

- 개발 서버의 시작 속도가 매우 빠르고 코드 수정 시 즉각적인 반영을 보여준다

- 파일을 필요할 때만 요청해 속도를 높이고, 배포 시에는 최적화된 파일로 묶어주는(번들링) 역할을 수행



### Build

- 프로젝트의 소스 코드를 최적화하고 번들링하여 배포할 수 있는 형식으로 변환하는 과정

- 개발 중에 사용되는 여러 소스 파일 및 리소스를 최적하된 형태로 조합하여 최종 소프트웨어 제품을 생성하는 것

> vite는 이런 빌드 프로세스를 수행하는데 사용되는 도구



## Vue Project 생성

- vue project(app) 생성 vite 기반 빌드

``` 
npm create vue@latest
cd vue-project
npm install
npm run dev
```



## NPM(Node Package Manager)

> Node.js의 기본 패키지 관리자

- npm은 개발자들이 만든 js 패키지를 모아놓은 거대한 저장소

- 패키지들을 쉽게 설치하고 관리할 수 있게 해주는 명령어 도구

- npm install 명령어로 간편하게 다운로드해서 사용가능

- 모든 패키지 목록과 버전을 package.json 파일에 기록하여, 다른 사람과 협업하거나 다른 환경에서 작업할 때도 동일한 개발 환경을 쉽게 구축할 수 있도록 도와줌



### Node.js

- Chromd의 V8 js 엔진을 기반으로 하는 Server-Side 실행 환경

- 브라우저 안에서만 동작할 수 있었던 js를 브라우저가 아닌 서버 측에서도 실행할 수 있게 함
  
  - 프론트 엔드와 백엔드에서 동일한 언어로 개발할 수 있게 됨

- NPM을 활용해 수많은 오픈 소스 패키지와 라이브러리를 제공하여 개발자들이 손쉽게 코드를 공유하고 재사용할 수 있게함



### Module

> 프로그램을 구성하는 독립적인 코드 블록(.js 파일)

- app의 크기가 커지면서 파일을 여러 개로 분리하여 관리

- 분리된 각 파일이 모듈이다

#### Module의 한계

- 앱이 처리해야하는 js 모듈의 개수도 극적으로 증가

- 이러한 상황에서 성능 병목 현상이 발생하고 모듈 간의 의존성이 깊어지면서 특정한 곳에 발생한 문제가 어떤 모듈 간의 문제인지 파악하기 어려워 짐

- 복잡하고 깊은 모듈 간 의존성 문제를 해결하기 위한 도구가 필요
  
  - Bundler!



### Bundler

> 여러 모듈과 파일을 하나의 번들로 묶고 최적화하여 사용할 수 있게 만들어 주는 도구

- Bundler는 여러 개로 나뉜 js 모듈 파일들을 하나의 파일로 합쳐 주는 도구

- 브라우저가 수많은 파일을 각각 요청하여 생기는 네트워크 부담을 줄이고 코드를 브라우저가 이해할 수 있는 형태로 변환

- 웹사이트의 로딩 속도를 높이고 성능을 최적화



### Bundler의 역할

- 의존성 관리, 코드 최적화, 리소스 관리 등

- Bundler가 하는 작업을 Bundling이라 함

> vite는 rollup이라는 bundler를 사용하며 개발자가 별도로 기타 환경설정에 신경쓰지 않도록 모두 설정해두고 있음

- 번들링의 핵심 목표는 여러 파일을 하나로 묶어 http 요청을 줄여 웹 로딩 속도를 개선하는 것

- js뿐 아니라, css, 이미 등 정적 자원을 함께 처리하고, 최적화 하는 역할도 

- import 하지 않은 코드는 **트리 쉐이킹** 을 통해 최종 번들 파일에서 자동으로 제거됨



### Vue project 기본 구조

#### public 디렉토리

- 주로 다음 정적 파일을 위치 시킴
  
  - 소스코드에서 참조되지 않는 코드
  
  - 항상 같은 이름을 갖는 코드
  
  - import 할 필요 없는 코드

- 항상 root 절대 경로를 사용하여 참조
  
  - public/icon.png 는 소스 코드에서 /icon.png로 참조 할 수 있음

#### src 디렉토리

- 프로젝트의 주요 소스코드를 포함하는 곳

- 실제로 우리가 작업하게 될 대부분의 소스 코드가 위치

- 컴포넌트, 스타일, 라우팅 등 프로젝트의 핵심 코드를 관리

#### src/assets

- 프로젝트 내에서 사용되는 정적 자원(이미지, 폰트, 스타일 시트 등)을 관리

- 컴포넌트 자체에서 참조하는 내부 파일을 저장하는데 사용

- 컴포넌트가 아닌 곳에서는 public 디렉토리에 위치한 파일을 사용

#### src/components

- 프로젝트의 주요 소스 코드를 포함하는 곳

- 실제로 우리가 작업하게 될 댇부분의 소스 코드가 위치

- 컴포넌트, 스타일, 라우팅 등 프로젝트의 핵심 코드를 관리

#### src/App.vue

- vue 앱의 root 컴포넌트

- 다른 하위 컴포넌트들을 포함

- 앱 전체의 레이아웃과 공통적인 요소를 정의

#### src/main.js

- vue 앱을 초기화하고, app.vue 를 dom에 마운트하는 시작점

- 필요한 라이브러리를 import 하고 전역 설정을 수행

#### index.html

- vue 앱의 기본 html 파일

- main.js에서 app.vue 컴포넌트를 렌더링하고, index.html 특정 위치를 마운트 시킴

- 필요한 스타일 시트, 스크립트 등의 외부 리소스를 로드할 수 있음 bootstrap CDN 등

#### 기타 설정 파일

##### jsconfig.json

- 컴파일 옵션, 모듈 시스템 등 설정

##### vite.config.js

- vite 프로젝트 설정 파일

- 플러그인, 빌드 옵션, 개발 서버 설정 등



### 패키지 관리

#### package.json

- 프로젝트에 관한 기본 정보와 패키지 의존성을 정의하는 설계도 파일(메타데이터 파일)

- 프로젝트가 어떤 패키지를 사용하고, 어떤 스크립트를 실행할 수 있는지 명시

- npm install 시 이를 참조하여 패키지를 설치
  
  - 어떤 패키지를 설치해야 하는지 결정하는 기준 제공

- 프로젝트 메타 데이터
  
  - 프로젝트 이름, 버전, 스크립트 명령, 패키지 의존성 등의 정보가 명시됨

- 의존성 목록
  
  - 어떤 패키지를 사용하는지, 어떤 버전 범위를 허용하는지를 기록

> 집을 짓기 전에 필요한 재료 목록과 건축 계획서
> 
> > 필요한 재료(패키지)와 대략적 규격(버전 범위)을 알려주는 문서



##### package-lock.json

- package.json을 기반으로 실제 설치된 패키지들의 정확한 버전 정보를 기록하는 파일

- 실제로 어느 버전 패키지가 설치되었는지 확정하고 기록

- 다른 환경에서도 동일한 패키지 구성을 재현 가능하게 함

- 정확한 버전 고정
  
  - 프로젝트를 설치할 때 실제로 어떤 버전의 패키지가 설치 되었는지 기록

- 빌드 안정성 보장
  
  - 협업 또는 배포 환경에서, 모든 개발자가 동일한 패키지 버전을 사용하도록 보장

- 자동 관리
  
  - npm install 결과가 반영되어 매번 자동 업데이트

> 장바구니에 담긴 물건들의 정확한 브랜드와 생산일자가 적힌 구매 내역서
> 
> (실제 구매된 물건의 구체적 스펙을 담은 문서)



#### node_modules

- package.json과 package-lock.json에 따라 실제로 설치된 모든 패키지가 저장되는 곳

- 프로젝트 실행시 필요한 모든 라이브러리와 코드 파일을 보관

- 앱 구동 시 참조되는 실제 데이터 저장소

- npm install 을 통해 설치된 모든 패키지들이 실제로 저장
  
  - 개발시 직접 수정할 필요는 없으며 npm install 시 자동 관리됨
    
    - 직접 수정하지 않고, 필요시 npm install로 언제든 재생성 가능

- 용량이 매우 클 수 있으며, 협업 시 일반적으로 git으로 추적하지 않음(.gitignore에 포함)



> 계획서와 내역서대로 확보한 실제 건축 자재들이 쌓여있는 창고



#### 패키지 관리 정리

- package.json
  
  - 어떤 패키지가 필요하고 어떤 버전 범위를 허용할지 정의하는 설계도

- package-lock.json
  
  - 실제로 설치한 패키지의 정확한 버전을 기록하는 상세 내역서

- node_modules
  
  - 설계도와 내역서에 따라 내려받은 실제 패키지 자재창고





### Virtual DOM

#### Vue에서는 직접적으로  DOM에 접근하는 것을 권장하지 않음

-  js 에서 사용하는  dom 접근 관련 메서드 사용 금지

- querySelector, createElement, addEventListener 등

- vue의 ref와 lifecycle hook 함수를 통해 간접적으로 접근
  
  - 성능과 코드의 예측 가능성을 극대화
  
  - 이를 가능하게 하는게 가상돔(virtual dom)



> 가상의 dom을 메모리에 저장하고 실제 dom과 동기화하는 프로그래밍 개념

- 실제 dom과의 변경 사항 비교를 통해 변경된 부분만 실제 dom에ㅐ 적용하는 방식

- 웹 앱의 성능을 향상시키기 위한 vue의 내부 렌더링 기술



#### V Dom 내부 렌더링 과정

1. 작성한 html 템플릿을 virtual dom을 그려내느 ㄴ설계도로 변환

2. 렌더 함수 코드를 바탕으로 vdom을 생성

3. vdom을 실제 dom에 마운트

4. 컴포넌트의 데이터(반응형 상태)가 바뀔 때마다 새로운 가상돔을 만들어 이전과 비교하고 바뀐 부분만 효율적으로 찾아 실제 dom을 업데이터



#### V dom 패턴의 장점

1. 효율성
   
   - 실제 dom 조작을 최소화하고 변경된 부분만 업데이트하여 성능을 향상

2. 반응성
   
   - 데이터 변경을 감지하고, vdom을 효율적으로 갱신하여 ui를 자동으로 업데이트

3. 추상화
   
   - 개발자는 실제 dom  조작을 vue에게 맡기고 컴포넌트와 템플릿을 활용하는 추상화된 프로그래밍 방식으로 원하는  ui 구조를 구성하고 관리할 수 있음

#### 주의사항

- 실제 dom에 직접 접근하지 말것
  
  - js에서 사용하는 dom 관련 메서드 사용금지
  
  - 아래와 같은 예측 불가능한 문제가 발생할 수 잇음
    
    1. 데이터와 화면의 불일치
    
    2. 예측 불가능한 렌더링
    
    3. 코드의 복잡성 증가

> vue의 ref(()와 Lifecycle Hooks 함수를 사용해 간접적으로 접근하여 조작할 것



- 직접 dom 엘리먼트에 접근해야 하는 경우

- ref 속성을 사용하여 특정  dom element에 직접적인 참조를 얻을 수 이씀



## 참고

### Single Root Element

- 모든 컴포넌트에는 최상단 html 요소가 작성되는 것이 구너장

- 가독성, 스타일링, 명확한 컴포넌트 구조를 위해 각 컴포넌트에는 최상단  html 요소를 작성해야함



### CSS scoped 속성

- <style scoped>를 사용하면 해당 컴포넌트 내부의 스타일이 현재 컴포넌트 내부 요소에게만 적용되도록 범위를 제한하는 기능

- 스타일이 컴포넌트 바깥으로 유출되거나, 다른 컴포넌트에서 정의한 스타일이 현재 컴포넌트를 침범하지 않도록 막아줌

- CSS scoped를 사용하지 않는다면?
  
  - 해당 스타일은 전역에 영향을 미침
  
  - 예를 들어, 다른 컴포넌트에서도 div 태그를 사용했다면 그 스타일이 함께 적용됨

##### 부모-자식 관계에서의 스타일 전파

- 일반적으로  scoped 스타일은 부모 컴포넌트의 스타일이 자식 컴포넌트에 영향을 미치지 않음

- 하지만 예외적으로 자식 컴포넌트의 "최상위 요소(Root element)"에는 부모 컴포넌트의 scoped 스타일도 영향을 줄 수 있음

- 이는 부모가 자식 컴포넌트를 레이아웃 할 때 필요한 경우가 있기 때문

- 즉, 자식 컴포넌트의 가장 바깥 쪽을 감싸는 요소에 한해서는 부모의 scoped 스타일 적용이 의도적으로 허용되어 있음

- 부모 컴포넌트에 적용한 스타일이 style scoped로 돼있고 div의 컬러를 red로 표시한다고 할때, 자식의 최상위 요소(div)는 부모와 본인의 css 모두의 영향을 받기 때문에 부모 컴포넌트에 지정한 스타일이 적용됨

#### CSS scoped를 적용한 이유

- vue는 부모 컴포넌트가 자식 컴포넌트의 최상위 요소 스타일을 제어할 수 있어야 레이아웃 목적을 쉽게 달성할 수 있다고 판단했기 때문

- 이로 인해 자식 컴포넌트의 root element는 부모와 자식 모두의  scoped 스타일이 영향을 미칠 수 잇음

> 최상위 app 컴포넌트에서 레이아웃 스타일을 전역적으로 구성할 수 있지만, 다른 모든 컴포넌트는 범위가 지정된 스타일을 사용하는 것을 권장





## 패키지 관리 주의 사항

1. `npm install`을 입력하는 위치
   
   - 항상 프로젝트 루트 디렉토리(프로젝트를 생성한 폴더)에서 실행

2. `node_modules` 폴더 관리 주의
   
   - 필요할 때마다 `npm install`을 통해 재생성할 수 있으므로, 직접 수정하거나 git으로 관리할 필요가 없음

3. package.json과 package-lock.json 직접 편집 자제
   
   - `npm install` 패키지명 명령을 통해 자동 업데이트하는 것이 안전

4. 문제가 발생했을 때 재 설치 고려
   
   - 패키지 버전 충돌이나 이상 동작이 의심될 때는 node_modules 폴더를 삭제한 뒤 다시 npm install을 실행





























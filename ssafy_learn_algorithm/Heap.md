# Heap

- 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조

- 최대힙
  
  - 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  
  - 부모노드의 키값 > 자식노드의 키값
  
  - 루트노드 : 키값이 가장 큰 노드

- 최소힙
  
  - 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  
  - 부모노드의 키값 < 자식노드의 키값
  
  - 루트 노드 : 키값이 가장 작은 노드

# **힙(Heap)**

# 1. 힙이란 무엇일까?

## 개념: 토너먼트 대진표

힙(Heap)**은 '최댓값'이나 '최솟값'을 빠르게 찾기 위해** 고안된 완전 이진 트리 기반의 자료구조입니다.

가장 대표적인 예시는 **'토너먼트 대진표'**입니다.

licensed-image.jfif

- **힙의 규칙:** "부모 노드는 항상 자식 노드보다 강하다(값이 크거나 작다)."
- **토너먼트 대진표:** "부모 노드(승자)는 항상 자식 노드(패자)보다 강하다."

이 간단한 규칙 덕분에, 우리는 대진표의 맨 꼭대기(**루트 노드**)만 보면 **누가 최종 우승자인지(최댓값 또는 최솟값)** 한눈에 알 수 있습니다. 힙은 이 원리를 이용해 원하는 값을 $O(1)$의 시간 복잡도로 즉시 조회할 수 있습니다.

---

# 2. 힙의 종류와 특징

## 힙의 종류

1. **최대 힙(Max-Heap)**
   - 부모 노드의 값이 자식 노드의 값보다 항상 **크거나 같은** 힙. **(**부모 노드의 키 `$≥$` 자식 노드 키)
   - 루트 노드는 최댓값.
   - 부모가 자식보다 큰(또는 같은) 구조 유지
   - 키 값이 가장 큰 노드를 찾기 위한 **완전 이진 트리**
2. **최소 힙(Min-Heap)**
   - 부모 노드의 값이 자식 노드의 값보다 항상 **작거나 같은** 힙. **(**부모 노드의 키 `$≤$` 자식 노드 키)
   - 루트 노드는 최솟값.
   - 부모가 자식보다 작은(또는 같은) 구조 유지
   - 키 값이 가장 작은 노드를 찾기 위한 **완전 이진 트리**

## **핵심 특징**

1. **완전 이진 트리**
   
   - 힙은 항상 완전 이진 트리의 형태를 유지합니다.
   - 이 덕분에 리스트(배열)를 사용해 효율적으로 구현할 수 있습니다.

2. **부모-자식 인덱스 관계 (0-based index)**
   
   - 부모 인덱스: `(자식 인덱스 - 1) // 2`
   
   - 왼쪽 자식 인덱스: `(부모 인덱스 * 2) + 1`
   
   - 오른쪽 자식 인덱스: `(부모 인덱스 * 2) + 2`
   
   - **예시: `[1, 3, 2, 4, 5, 8]` 리스트를 트리 구조로 읽기**
     
     - **루트 `1` (index 0)의 자식:**
       
       - 왼쪽: `(0 * 2) + 1 = 1` → `heap[1]`은 `3`
       - 오른쪽: `(0 * 2) + 2 = 2` → `heap[2]`은 `2`
     
     - **노드 `3` (index 1)의 자식:**
       
       - 왼쪽: `(1 * 2) + 1 = 3` → `heap[3]`은 `4`
       - 오른쪽: `(1 * 2) + 2 = 4` → `heap[4]`은 `5`
       
       ```
            1
           / \\
          3   2
         / \\   /
        4   5 8
       ```

3. **시간 복잡도**
   
   - **최대/최솟값 조회:** $O(1)$
   - **데이터 삽입/삭제:** $O(logN)$ (트리의 높이에 비례)

---

# 3. 힙의 핵심 연산

힙의 핵심은 새로운 데이터가 추가되거나 기존 데이터가 삭제될 때, **'힙의 규칙'을 다시 만족시키도록** 구조를 재조정하는 과정입니다.

## **삽입 (Push)**

> 원리: "일단 맨 끝에 추가하고, 이길 때까지 위로 올라간다!"

1. 새로운 데이터를 완전 이진 트리의 **마지막 위치**에 추가합니다.
2. 새로운 데이터와 **부모 노드의 값을 비교**합니다.
3. 만약 자식의 값이 부모보다 크다면(최대 힙 기준), 둘의 위치를 **교환(swap)**합니다.
4. 새로운 데이터가 제자리를 찾을 때까지(부모보다 작거나, 루트에 도달할 때까지) 이 과정을 반복합니다. (이를 **sift-up** 또는 **heapify-up**이라고 합니다.)

## **삭제 (Pop)**

> 원리: "우승자(루트)를 빼내고, 맨 끝의 후보를 데려와 아래로 내려보낸다!"

1. **루트 노드**(최댓값 또는 최솟값)를 제거하고 따로 보관합니다.
2. 가장 **마지막에 있던 노드**를 루트 자리로 이동시킵니다.
3. 새로운 루트가 자식 노드들보다 작다면(최대 힙 기준), **더 큰 자식과 위치를 교환**합니다.
4. 새로운 루트가 제자리를 찾을 때까지 이 과정을 반복하며 아래로 내려갑니다. (이를 **sift-down** 또는 **heapify-down**이라고 합니다.)

---

# **4. 파이썬 코드 구현 (최대 힙 예시)**

- 알고리즘 학습을 위해 `heapq` 모듈 없이 직접 최대 힙의 삽입과 삭제를 구현해 봅시다. (0-based index 사용)

```python
def heap_push(heap, item):
    """최대 힙에 원소를 추가하는 함수 (sift-up)"""
    # 1. 힙의 마지막 위치에 원소 추가
    heap.append(item)

    # 2. 새로 추가된 원소의 위치부터 루트까지, 부모와 비교하며 올라감
    child_idx = len(heap) - 1
    parent_idx = (child_idx - 1) // 2

    # 자식이 부모보다 크고, 아직 루트에 도달하지 않았다면 계속 반복
    while child_idx > 0 and heap[parent_idx] < heap[child_idx]:
        # 부모와 자식의 위치를 교환
        heap[parent_idx], heap[child_idx] = heap[child_idx], heap[parent_idx]
        # 다음 비교를 위해 인덱스를 위로 이동
        child_idx = parent_idx
        parent_idx = (child_idx - 1) // 2

def heap_pop(heap):
    """최대 힙에서 최댓값(루트)을 제거하고 반환하는 함수 (sift-down)"""
    # 힙에 원소가 하나뿐이거나 없다면 바로 처리
    if len(heap) <= 1:
        return heap.pop() if heap else None

    # 1. 루트 노드(최댓값)를 저장하고, 마지막 원소를 루트로 이동
    max_value = heap[0]
    heap[0] = heap.pop()

    # 2. 루트부터 시작하여 힙 속성을 만족할 때까지 아래로 내려감
    parent_idx = 0
    while True:
        left_child_idx = parent_idx * 2 + 1
        right_child_idx = parent_idx * 2 + 2
        largest_idx = parent_idx

        # 왼쪽 자식과 비교
        if (
            left_child_idx < len(heap)
            and heap[left_child_idx] > heap[largest_idx]
        ):
            largest_idx = left_child_idx

        # 오른쪽 자식과 비교
        if (
            right_child_idx < len(heap)
            and heap[right_child_idx] > heap[largest_idx]
        ):
            largest_idx = right_child_idx

        # 현재 노드가 자식들보다 크면 제자리를 찾은 것이므로 종료
        if largest_idx == parent_idx:
            break

        # 자식이 더 크다면 위치를 교환하고, 아래에서 계속 진행
        heap[parent_idx], heap[largest_idx] = (
            heap[largest_idx],
            heap[parent_idx],
        )
        parent_idx = largest_idx

    return max_value

# --- 실행 예시 ---
my_heap = []
heap_push(my_heap, 3)
heap_push(my_heap, 7)
heap_push(my_heap, 4)
heap_push(my_heap, 10)
heap_push(my_heap, 5)
print(f"힙 구성 결과: {my_heap}")  # [10, 7, 4, 3, 5]

print(f"최댓값 pop: {heap_pop(my_heap)}")  # 10
print(f"pop 이후 힙: {my_heap}")  # [7, 5, 4, 3]
```

```
힙 구성 결과: [10, 7, 4, 3, 5]
최댓값 pop: 10
pop 이후 힙: [7, 5, 4, 3]
```

---

# **5. 힙의 핵심 활용: 우선순위 큐**

힙의 "항상 최댓값/최솟값을 빠르게 찾을 수 있다"는 특징은 **우선순위 큐(Priority Queue)**를 구현하는 데 완벽하게 들어맞습니다. 우선순위 큐는 데이터가 들어온 순서가 아니라, **우선순위가 높은 순서**대로 처리해야 할 때 사용됩니다.

- **다익스트라 최단 경로 알고리즘:** 다음으로 탐색할 노드 중, 거리가 가장 짧은 노드를 우선적으로 선택할 때
- **운영체제 작업 스케줄링:** 여러 작업 중 우선순위가 가장 높은 작업을 먼저 처리할 때

파이썬에서는 `heapq` 모듈이 최소 힙 기반의 우선순위 큐 기능을 기본으로 제공합니다.

- [heapq 모듈](https://www.notion.so/heapq-2303cb37136a8104b49ac6d8c05a91e8?pvs=21)

---

## **[심화] 힙 정렬 (Heap Sort)**

힙 정렬은 힙 자료구조를 이용하여 배열을 정렬하는 알고리즘입니다.

1. 주어진 배열을 최대 힙으로 변환합니다.

2. 힙의 루트(배열의 첫 번째 원소, 최댓값)와 배열의 가장 마지막 원소를 교환합니다.

3. 배열의 마지막 원소를 제외하고, 나머지 부분에 대해 다시 힙 속성을 만족하도록 재조정합니다.

4. 이 과정을 배열의 크기가 1이 될 때까지 반복합니다.
   
   ```python
   def heap_sort(arr):
      # 1. 빈 힙 생성, 모든 원소 삽입 
      heap = [None]  # 1-based index 사용 가정
      for x in arr:
          heap_push(heap, x)
   
      sorted_arr = []
      # 2. 힙에서 최대(혹은 최소) pop하여 배열에 삽입 
      while len(heap) > 1:
          sorted_arr.append(heap_pop(heap))
      return sorted_arr
   ```
   
   - 이 과정을 거치면 배열이 오름차순으로 정렬되며, 시간 복잡도는 $O(NlogN)$입니다.

# 스택(Stack)

> 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조

- 대표적인 선형 자료구조 중 하나 (자료 간의 관계가 1:1. 트리는 1:N)

- 스택에 자료를 삽입하거나, 스택에서 자료를 꺼낼 수 있다

## 스택의 특성

### 후입선출(LIFO, Last-In-First-Out)

> 가장 마지막에 넣은 자료가 가장 먼저 나오는 것

- 1, 2, 3 순서로 넣었으면 꺼낼 때는 3, 2, 1 순서

### 스택을 구현하기 위한 자료구조와 연산

- 배열을 통해 구현
  
  - 파이썬의 리스트

- 저장소 자체를 스택이라 부르기도 함
  
  - 용도에 따라 메모리 일부를 스택으로 부름

- 스택에서 마지막 삽입된 원소를 위치
  
  - 스택 포인터, top으로 부르며 데이터를 넣거나 뺄 때 기준이 되는 위치

### 스택의 연산

- 삽입(push)
  
  - 저장소에 자료를 저장하는 연산으로 보통 push라고 부름

- 삭제(pop)
  
  - 저장소에서 삽입한 자료의 역순으로 꺼내는 연산으로, 보통 pop이라고 부른다

- 스택이 공백인지 아닌지 확인하는 연산(isEmpty)
  
  - 스택이 비어 있으면 True, 아니면 False를 반환

- 스택의 top에 있는 item(원소)을 반환하는 연산(peek)
  
  - 삭제는 하지 않는다

#### Push 연산

```python
def my_push(item):
    s.append(item

def my_push(item, size):
    global top
    top += 1
    if top == size:
        print('overflow!')
    else:
        stack[top] = item
```

> 인덱스 연산에서 미리 배열의 크기를 정해놨음 **주의**

#### Pop 연산

- 남은 데이터 중 가장 늦게 저장된 데이터를 삭제하는 연산

```python
def my_pop():
    if len(s) == 0:
        # underflow
        return
    else:
        return s.pop()  # 리스트 s의 마지막 원소 삭제
```

# Function Call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리

## 흐름(도식의 번호 순서)

1. `main()` 시작

2. **함수 호출** → `F_1()`

3. `F_1()` 실행

4. **함수 호출** → `F_2()`

5. `F_2()` 실행 → `end F_2()`

6. **복귀** → `F_1()`

7. `end F_1()`

8. **복귀** → `main()`

9. `end main()`

> **후입선출**: 가장 마지막에 넣은 데이터가 먼저 나오는 것

- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 **후입선출(LIFO)** 구조이므로, **스택**을 이용해 수행 순서를 관리한다.

### 시스템 스택

- 함수 수행에 필요한 **지역변수**, **매개변수**, **수행 후 복귀할 주소** 등을 저장합니다.

- 함수 호출이 발생하면 정보를 **스택 프레임(stack frame)**에 담아 **시스템 스택**에 삽입합니다.

```scss
[top] stack_Frame(F_2) ─ F_2() 함수 실행 관련 정보
      stack_Frame(F_1) ─ F_1() 함수 실행 관련 정보
      stack_Frame(main) ─ main() 함수 실행 관련 정보
```

#### 프로그램에서의 함수 호출과 복귀에 따른 수행 순서 관리

- 함수의 실행이 끝나면 시스템 스택의 **top 원소(스택 프레임)**를 삭제(pop)하면서, 프레임에 저장되어 있던 **복귀 주소**를 확인하고 복귀시킵니다.

- 함수 호출과 복귀에 따라 이 과정을 반복하여, 전체 프로그램 수행이 종료되면 **시스템 스택은 공백 스택**이 됩니다.
1) 호출/복귀 흐름

```scss
main()         F_1()            F_2()
 ① 시작
 ② ─────────▶  진입
               ③ 실행
               ④ ─────────────▶  진입
                                ⑤ 실행 후 end F_2()
               ⑥ ◀─────────────  복귀
               ⑦ end F_1()
 ⑧ ◀────────  복귀
 ⑨ end main()
```

2) 스택(top 위쪽) 상태 변화

```css
① [ main ]
② [ main, F_1 ]
④ [ main, F_1, F_2 ]
⑥ [ main, F_1 ]          # F_2 종료 → pop
⑧ [ main ]               # F_1 종료 → pop
⑨ [ ]                    # main 종료 → 공백 스택
```

3) 핵심 원리
- **후입선출(LIFO)**: 가장 마지막에 호출된 함수가 먼저 끝나서 복귀합니다.

- 함수가 끝날 때마다 시스템 스택의 **top 스택 프레임을 pop**하고, 그 안의 **복귀 주소**로 돌아갑니다.

## 재귀호출

> 함수가 자신과 같은 작업을 반복해야 할 때, 자신을 다시 호출하는 구조

#### 재귀함수의 기본형

- **아이디어**: 현재 호출 단계 `i`와 목표 단계 `N`을 **인자**로 사용한다.

- `f(i, N)`는 “현재 단계 `i`에서 시작해 `i == N`이 되면 멈춘다”는 가장 기본 형태다.

- 표기: **○ 재귀호출 진행**, **□ 재귀호출 중단**

##### 호출 흐름(예: `f(0, 3)`)

```ini
i=0  ○  → f(1, 3)
i=1  ○  → f(2, 3)
i=2  ○  → f(3, 3)
i=3  □  (중단)
```

##### 기본코드

```python
def f(i, N):
    if i == N:        # 중단 조건
        return
    else:             # 재귀 호출
        f(i + 1, N)
```

>  사용 예시: `f(0, 3)` → `i=0 → 1 → 2 → 3`에서 종료.



## 피보나치 재귀호출의 문제점

- 피보나치 수를 구하는 재귀함수는 엄청난 중복호출이 존재한다

- 따라서 최적화를 위해 **`Memoization`** 을 사용

## Memoization(메모이제이션)

> 컴퓨터 프로그램을 실행할 때에 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술

### 피보나치 메모이제이션 예시

```python
# memo를 위한 배열을 할당하고, 모두 0으로 초기화 한다;
# memo[0]을 0으로 memo[1]는 1로 초기화 한다;

def fibo1(n):
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n]

memo = [0] * (n + 1)
memo[0] = 0
memo[1] = 1

```

# String

## 코드체계

> 문자에 대응하는 숫자를 정한 것

- 네트워크가 발전되기 전 지역별로 코드체계를 정해놓고 자기들끼리만 사용

- 네트워크가 발전하면서 정보를 주고 받을 때 정보를 달리 해석하게 됐다

### 코드체계의 개선

- 혼동을 피하기 위해 표준안을 만듦

- 미국에서 ASCII 문자 인코딩 표준 제정

- ASCII는 7-bit 128문자 이루어짐

- Extended ASCII로 부가적인 문자 128개 추가

## 유니코드

- 컴퓨터가 발전하면서 각 나라에서 컴퓨터가 발전함

- 다국어 처리를 위해 표준인 유니코드를 만듦

## 문자열(String)

> 문자들이 순서대로 나열된 데이터

- 문자열 기호
  
  - 홑따옴표 : ' '
  
  - 쌍따옴표 : " "
  
  - 홑따옴표 3개 : ''' '''
  
  - 쌍따옴표 3개 : """ """

- 연산
  
  - +연결 : 문자열 + 문자열으로, 이어 붙여주는 역할
  
  - *반복 : 문자열 * 수, 수만큼 문자열이 반복 

- 데이터의 순서가 구분되는 Sequence 자료형으로 분류된다
  
  - 인덱싱, 슬라이싱 연산들을 사용가능

- 튜플과 마찬가지로 요소값을 변경할 수 없다(immutable)

## 문자열 비교

### `==`연산자와 `is` 연산자

- `==`는 값(value, 평가값)이 같은지 비교

- `is`는 객체의 정체성, 같은 **객체(메모리 주소)** 인지 비교한다

### 문자열 숫자를 숫자 타입으로 변환

- `a = int('123')`

- `b = float('3.14')`

- `c = int('A0',16)` 
  
  - 문자열 'A0'를 16진법으로 해석해서 변환

## 패턴 매칭

### 고지식한 알고리즘(Brute Force)

- 단순한 방법. 일일이 다 비교

- 최악의 시간복잡도!

### KMP 알고리즘

- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
  
  - 불일치가 발생한 글자의 앞 부분에 어떤 문자가 있는지를 미리 알고 있게 됩니다.
    
    - 조건에 따라, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않을 수 있습니다.
    
    - 불일치가 발생했을 경우 이동할 다음 위치를 계산하는 **전처리**가 필요합니다.
    
    - **시간 복잡도**
      
      - 패턴의 길이가 M일 때 전처리에 걸리는 시간은 `O(M)`입니다.
      
      - 텍스트의 길이가 N일 때 검색은 최악의 경우 `O(N)`입니다.
      
      - 결과적으로 `O(M+N)`이 됩니다.
      
      - 만약 M이 고정된 값으로 매우 짧다면 평균적으로 `Θ(N)`이 됩니다.

그 그림은 **KMP(Knuth–Morris–Pratt) 문자열 검색의 핵심 아이디어**를 보여줘요.

- 상황: 텍스트 T에 `... abcdabc d ...`가 있고, 패턴 P는 `abcdabc e f`.  
  여기서 `abcdabc`까지는 **일치**, 다음 글자에서 `e(패턴)` vs `d(텍스트)`가 **불일치**났죠.

- 순진한 방법(브루트포스)이면 패턴을 한 칸만 옮겨 처음부터 다시 `a,b,c...`를 또 비교해야 해요.  
  하지만 이미 비교해 본 결과, 방금까지 맞춘 `abcdabc`의 **접미사 `abc`**가 패턴의 **접두사 `abc`**와 **같다**는 사실을 알고 있죠.

- 그래서 패턴을 **불필요한 재비교 없이** 바로 이렇게 옮깁니다:  
  `abcdabc`(일치 구간)의 **가장 긴 접두사=접미사(LPS)** 길이는 `3`(=`abc`).  
  방금 맞춘 길이가 `7`이므로 **이동량 = 7 - 3 = 4칸**.  
  즉, 패턴의 접두사 `abc`를 텍스트의 방금 일치했던 접미사 `abc` 위로 **정렬**해요(그림의 “이만큼 shift”).

- 이동 후 비교는 **처음부터가 아니라**, 패턴에서 이미 일치한 접두사 길이만큼 건너뛴 **다음 위치**(인덱스 3, 즉 `d`)부터 재개합니다.  
  KMP 용어로는, 불일치가 난 시점의 패턴 인덱스 `j`를 **π(j-1)=LPS** 값으로 되돌리고, 텍스트 인덱스는 그대로 둔 채 비교를 이어갑니다.

요약: “이미 알고 있는 **접두사=접미사 중 가장 긴 길이(LPS)**만큼 패턴을 크게 점프해서, **다시 검사할 필요 없는 구간을 건너뛴다**.”  
이게 KMP가 `O(N)`으로 빠른 이유예요.



### 보이어-무어 알고리즘

- 상용 소프트웨어에서 채택하고 있는 알고리즘

- 실제 검색에서 매우 빠른 성능
  
  - 패턴 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동거리는 패턴의 길이 만큼이 된다.

##### 불일치 문자 휴리스틱

- 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우
  
  - 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프한다
  
  - 



# 문자열 매칭 알고리즘 비교

- 찾고자 하는 문자열 패턴의 길이 `m`, 총 문자열 길이 `n`

- 고지식한 패턴 검색 알고리즘: 수행시간 `O(mn)`

- 카프-라빈 알고리즘: 수행시간 `Θ(n)`

- KMP 알고리즘: 수행시간 `Θ(n)`

- 보이어-무어 알고리즘
  
  - 앞의 두 매칭 알고리즘은 텍스트 문자열의 문자를 적어도 한 번씩 훑기 때문에 최선의 경우에도 `Ω(n)`입니다.
  
  - 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 됩니다.
  
  - 패턴의 오른쪽부터 비교합니다.
  
  - 완전한 보이어-무어 알고리즘은 일치 전파 휴리스틱을 함께 사용합니다.
  
  - 최악의 경우 `O(mn)`이지만 일반적으로 `o(n)`보다 시간이 덜 듭니다.
  
  - `grep`, VS Code, JVM 등에서 사용된다고 알려져 있습니다.

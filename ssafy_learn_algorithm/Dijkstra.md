# **최단 경로(Shortest Path)**

<aside>
💡

간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로

</aside>

# **1. 최단 경로란 무엇일까?**

### **1.1 개념: 내비게이션 길 찾기**

**최단 경로(Shortest Path)** 문제는 그래프의 두 정점 사이를 잇는 여러 경로 중, **간선의 가중치 합이 최소가 되는 경로**를 찾는 문제입니다.

이는 마치 내비게이션 앱에서 "A 지점에서 B 지점까지 **가장 빠른 길**로 안내해 줘"라고 요청하는 것과 같습니다. 이때 각 도로는 **간선(Edge)**, 교차로는 **정점(Vertex)**, 도로를 지나는 데 걸리는 시간이나 거리는 **가중치(Weight)**가 됩니다.

- **단일 출발 최단 경로 (Single-Source Shortest Path):** 특정 **시작 정점**에서 다른 **모든 정점**까지의 최단 경로를 찾는 문제. (예: 우리 집에서 다른 모든 친구 집까지 가는 최단 경로)
- **모든 쌍 최단 경로 (All-Pairs Shortest Path):** **모든 정점 쌍** 사이의 최단 경로를 찾는 문제.

우리는 이 중 가장 대표적인 '단일 출발 최단 경로' 문제의 해법인 **다익스트라 알고리즘**을 집중적으로 학습합니다.

---

# **2. 다익스트라 (Dijkstra) 알고리즘**

[Dijkstras Shortest Path Algorithm Explained | With Example | Graph Theory](https://www.youtube.com/watch?v=bZkzH5x0SKU)

<aside>
💡

한 정점에서 다른 모든 정점으로의 최단 경로를 구하는 알고리즘

**음의 가중치가 없는 그래프**에서, 특정 시작 정점으로부터 다른 모든 정점까지의 최단 경로를 찾는 대표적인 알고리즘입니다.

</aside>

## **2.1 핵심 아이디어: 가장 가까운 곳부터 확정하기**

다익스트라 알고리즘은 **그리디(Greedy) 접근법**을 사용합니다.

1. 출발점에서 각 정점까지의 거리를 기록할 `distance` 배열을 만듭니다. (출발점은 0, 나머지는 무한대(INF)로 초기화)
2. **현재까지 알려진 가장 가까운(최단 거리가 가장 짧은) 노드**를 하나 선택합니다.
3. 선택한 노드를 거쳐 다른 노드로 가는 경로가, 기존에 알려진 경로보다 더 짧다면 `distance` 배열의 값을 **갱신**합니다.
4. 모든 노드를 방문할 때까지 2~3번 과정을 반복합니다.

## **2.2 코드 구현 및 해설**

'현재까지 알려진 가장 가까운 노드'를 매번 효율적으로 찾기 위해 **우선순위 큐(최소 힙)**를 사용하는 것이 표준적인 구현 방식입니다.

- 동작 과정 이미지

```python
# import sys
import heapq

# sys.stdin = open('input.txt')

def dijkstra(start_node, num_vertices, adj_list):
    """
    Dijkstra 알고리즘 (우선순위 큐 활용)
    """
    # 1. 초기화
    # 모든 정점까지의 거리를 무한대(INF)로 초기화
    INF = float('inf')
    distance = [INF] * (num_vertices + 1)

    # 우선순위 큐(최소 힙) 생성
    priority_queue = []

    # 2. 시작 노드 처리
    # 시작 노드까지의 거리는 0으로 설정하고, 우선순위 큐에 삽입
    # 힙에는 (거리, 노드 번호) 순서로 저장하여, 거리가 짧은 순으로 정렬되도록 함
    distance[start_node] = 0
    heapq.heappush(priority_queue, (0, start_node))

    # 3. 메인 루프: 큐가 빌 때까지 반복
    while priority_queue:
        # 4. 현재까지 가장 거리가 짧은 노드를 힙에서 꺼냄
        current_dist, current_node = heapq.heappop(priority_queue)

        # 이미 처리된 노드라면(더 짧은 경로를 이미 발견했다면) 무시
        # 내가 과거에 이 현재 노드에 더 짧게 방문한 적이 있다면 더이상의 탐색은 무의미
        if distance[current_node] < current_dist:
            continue

        # 5. 현재 노드와 인접한 노드들을 확인
        for adj_node, weight in adj_list[current_node]:
            # 새로운 경로 = 시작점 -> 현재 노드 거리 + 가중치 -> 인접 노드 가중치
            new_dist = current_dist + weight

            # 6. 간선 완화(Relaxation): 새로운 경로가 기존 경로보다 더 짧으면 갱신
            if new_dist < distance[adj_node]:
                distance[adj_node] = new_dist
                # 갱신된 정보를 우선순위 큐에 추가 (거리, 정점) 순서로 변경해서 추가
                heapq.heappush(priority_queue, (new_dist, adj_node))

    return distance
```

```python
# --- 실행 예시 ---
# V, E = map(int, input().split())
# start = int(input())
# adj_list = [[] for _ in range(V + 1)]
# for _ in range(E):
#     u, v, w = map(int, input().split())
#     adj_list[u].append((v, w))

# (예시 데이터 직접 입력)
V, E, start = 6, 9, 1
adj_list = [
    [],
    [(2, 2), (3, 5), (4, 1)],  # (정점, 가중치)
    [(1, 2), (3, 3), (4, 2)],
    [(1, 5), (2, 3), (5, 5)],
    [(1, 1), (2, 2), (5, 1)],
    [(3, 5), (4, 1), (6, 2)],
    [(5, 2)],
]

# 다익스트라 알고리즘 실행
shortest_distances = dijkstra(start, V, adj_list)

# 1번 노드에서 각 노드까지의 최단 거리
print(shortest_distances)  # [inf, 0, 2, 5, 1, 2, 4]

# 결과 출력
for i in range(1, V + 1):
    if shortest_distances[i] == float('inf'):
        print(f"1번 노드에서 {i}번 노드까지: 도달 불가")
    else:
        print(
            f"1번 노드에서 {i}번 노드까지의 최단 거리: {shortest_distances[i]}"
        )
```

```
[inf, 0, 2, 5, 1, 2, 4]
1번 노드에서 1번 노드까지의 최단 거리: 0
1번 노드에서 2번 노드까지의 최단 거리: 2
1번 노드에서 3번 노드까지의 최단 거리: 5
1번 노드에서 4번 노드까지의 최단 거리: 1
1번 노드에서 5번 노드까지의 최단 거리: 2
1번 노드에서 6번 노드까지의 최단 거리: 4
```

- `heapq`가 어떻게 튜플의 첫 번째 요소인 가중치를 기준으로 정렬할까?
  
  **파이썬의 튜플(tuple) 비교 방식**
  
  파이썬에서 두 튜플의 크기를 비교할 때, 다음과 같은 순서로 동작합니다.
  
  1. 가장 먼저 **첫 번째 요소(`인덱스 0`)**를 비교합니다.
  2. 만약 첫 번째 요소에서 승패가 갈리면(한쪽이 더 작으면), **두 번째 요소는 아예 쳐다보지도 않고** 전체 튜플의 크기를 결정합니다.
  3. 첫 번째 요소가 같을 때만, 비로소 두 번째 요소를 비교하여 순서를 결정합니다.
  
  **예시:**
  
  - `(5, 10)` 과 `(10, 1)`을 비교하면, 파이썬은 첫 요소 `5`와 `10`을 비교하고, `5 < 10`이므로 **`(5, 10)`이 더 작다**고 즉시 판단합니다. 뒤에 있는 `10`과 `1`은 비교조차 하지 않습니다.
  - `(5, 10)` 과 `(5, 1)`을 비교하면, 첫 요소가 `5`로 같으므로 두 번째 요소 `10`과 `1`을 비교하여 **`(5, 1)`이 더 작다**고 판단합니다.
  
  **다익스트라 코드에 적**
  
  다익스트라 코드에서는 `(거리, 노드 번호)` 형태의 튜플을 우선순위 큐(최소 힙)에 넣습니다./
  
  ```python
  heapq.heappush(priority_queue, (new_dist, adj_node))
  ```
  
  최소 힙은 내부적으로 **가장 작은 값**을 항상 루트에 두려고 아이템들을 비교하고 정렬합니다.
  
  `heapq`가 `(4, 5)`와 `(2, 3)`이라는 두 튜플 중 어느 것이 더 작은지 비교해야 할 때, 파이썬의 규칙에 따라 **첫 번째 요소인 거리(`4`와 `2`)**를 먼저 비교합니다. `2`가 `4`보다 작으므로, `heapq`는 **`(2, 3)`**을 더 작은 값으로 판단하고 힙의 더 위쪽에 배치합니다.
  
  따라서 `heapq.heappush(priority_queue, (거리, 노드))` 코드는, **튜플의 첫 번째 요소인 '거리'를 우선적인 정렬 기준으로 사용**할 수 있습니다.

## 2.3 힙을 사용하는 이유

<aside>
💡

"아직 방문하지 않은 정점 중, 출발점으로부터 가장 가까운 정점을 가장 빠르게 찾기 위해서”

</aside>

### **2.3.1 힙이 없을 때 vs. 있을 때**

**1. 힙이 없다면: 모든 후보를 일일이 확인하는 방식**

만약 힙을 사용하지 않는다면, 매 단계마다 다음과 같은 비효율적인 과정을 거쳐야 합니다.

> "현재까지 알아낸 거리 정보를 담고 있는 distance 배열의 모든 원소를 처음부터 끝까지 훑어보면서, 그중 방문하지 않았고 거리가 가장 짧은 정점을 찾아야 한다."

이는 정점의 개수가 V개일 때, 다음 정점을 찾는 데에만 `$O(V)$`의 시간이 걸립니다. 이 과정을 모든 정점에 대해 반복하므로, 알고리즘의 전체 시간 복잡도는 `$O(V²)$`가 됩니다.

**2. 힙이 있다면: 가장 중요한 일(가장 가까운 정점)을 바로 알려주는 비서**

최소 힙은 **'우선순위 큐(Priority Queue)'**를 구현하는 데 사용되는 자료구조로, "가장 작은 값을 항상 맨 위에 유지"하는 특징이 있습니다.

다익스트라 알고리즘에 힙을 도입하면, 과정이 다음과 같이 극적으로 개선됩니다.

> "다음으로 방문할 후보 정점들을 최소 힙에 넣어 관리한다. 힙은 가장 거리가 짧은 정점을 항상 루트(맨 위)에 두기 때문에, 다음 정점을 찾을 때 그냥 힙에서 하나 꺼내기만 하면 된다."

힙에서 최소값을 꺼내는 연산은 `$O(log V)$`의 시간이 걸립니다. 모든 간선(E)에 대해 이 과정을 수행할 수 있으므로, 알고리즘의 전체 시간 복잡도는 `$O(E log V)$`로 크게 개선됩니다.

| 구분              | **힙(Heap) 미사용**             | **힙(Heap) 사용**               |
| --------------- | --------------------------- | ---------------------------- |
| **다음 정점 탐색 방식** | `distance` 배열 전체를 **선형 탐색** | **힙에서 pop** (최소값 즉시 반환)      |
| **시간 복잡도**      | $O(V^2)$                    | **$O(ElogV)$**               |
| **결론**          | 정점 개수가 많아지면 매우 비효율적         | 정점과 간선이 많은 그래프에서도 **매우 효율적** |

- **최소 힙**은 다익스트라 알고리즘이 매 순간 "가장 거리가 짧은 정점"이라는 최적의 선택을 가장 효율적으로 할 수 있도록 돕는 **핵심적인 도구**

---

# 3. 다익스트라의 특징과 한계

- **시간 복잡도:** **`$O(ElogV)$`** (우선순위 큐 사용 시)
- **핵심 자료구조:** **우선순위 큐(힙)**
- **한계**
  - 간선의 가중치가 **음수**일 경우에는 올바르게 동작하지 않습니다.
    (음수 가중치가 있다면 벨만-포드 알고리즘을 사용해야 합니다.)

---

# 4. [심화 학습] 벨만-포드 & 플로이드-워셜 알고리즘

| 알고리즘        | **문제 유형**   | **시간 복잡도**     | **음의 간선** |
| ----------- | ----------- | -------------- | --------- |
| **다익스트라**   | 단일 출발 최단 경로 | **$O(ElogV)$** | **불가**    |
| **벨만-포드**   | 단일 출발 최단 경로 | $O(VE)$        | **가능**    |
| **플로이드-워셜** | 모든 쌍 최단 경로  | $O(V^3)$       | **가능**    |

- **벨만-포드:** 음수 가중치가 있을 때 사용하며, 음수 사이클 존재 여부도 판별할 수 있습니다.
- **플로이드-워셜:** 모든 정점에서 다른 모든 정점으로 가는 최단 경로를 한 번에 구하고 싶을 때 사용합니다.
- [[심화] 최단 경로](https://www.notion.so/26f3cb37136a80b39677dcc3630c0ee1?pvs=21)

---

# 심화 학습: 벨만-포드 & 플로이드-워셜 알고리즘

# **1. 벨만-포드 (Bellman-Ford) 알고리즘**

<aside>
📌

음수 가중치가 있어도 사용 가능하며, 시작점에서 각 정점까지의 최단 거리를 모든 간선을 반복적으로 검사하여 갱신하는 알고리즘

</aside>

다익스트라 알고리즘은 간선의 가중치가 음수일 때 사용할 수 없다는 치명적인 한계가 있습니다. 벨만-포드 알고리즘은 **음수 가중치가 포함된 그래프**에서도 단일 출발 최단 경로를 찾을 수 있는 강력한 알고리즘입니다.

## **핵심 아이디어: 모든 간선을 계속해서 확인하기**

다익스트라가 '가장 가까운 정점'을 우선적으로 확정하는 그리디(Greedy) 방식인 것과 달리, 벨만-포드는 동적 프로그래밍(DP)과 유사한 방식을 사용합니다.

> "모든 간선(Edge)을 한 번씩 확인하는 과정을, 전체 정점(Vertex) 개수만큼 반복하면서 최단 거리를 점진적으로 갱신한다."

이 과정을 통해, 음수 가중치를 거쳐 가는 더 짧은 경로를 모든 경우에 대해 충분히 고려할 수 있게 됩니다.

## **음수 사이클 판별**

벨만-포드의 가장 큰 특징 중 하나는 **음수 사이클(Negative Cycle)의 존재 여부를 판별**할 수 있다는 것입니다. 음수 사이클이란, 한 바퀴 돌 때마다 총 비용이 계속해서 줄어드는 경로를 의미하며, 이 경우 최단 경로는 정의될 수 없습니다.

- **동작:** 총 `V-1`번의 전체 간선 확인을 마친 후, **한 번 더** 전체 간선을 확인했을 때 또다시 거리 갱신이 일어난다면, 이는 음수 사이클이 존재한다는 의미입니다.

## **코드 구현**

- 동작 과정 이미지

```python
def bellman_ford(num_vertices, edges, start):
    """
    Bellman-Ford 알고리즘
    """
    INF = float('inf')
    distance = [INF] * (num_vertices + 1)
    distance[start] = 0

    # 1. (정점 개수 - 1)번 만큼, 모든 간선에 대해 완화(Relaxation) 작업 반복
    for i in range(num_vertices - 1):
        for u, v, w in edges:  # u:시작, v:도착, w:가중치
            # u까지의 경로가 존재하고, u를 거쳐 v로 가는 것이 더 짧으면 갱신
            if distance[u] != INF and distance[v] > distance[u] + w:
                distance[v] = distance[u] + w

    # 2. 음수 사이클 확인: V번째 반복에서도 갱신이 일어나는지 확인
    for u, v, w in edges:
        if distance[u] != INF and distance[v] > distance[u] + w:
            # V번째에도 갱신이 발생하면 음수 사이클 존재
            return None

    return distance
```

```python
# --- 실행 예시 ---

# 예시 데이터 직접 입력 (음수 가중치 O, 음수 사이클 X)
V, E, start = 5, 6, 1
# (시작, 도착, 가중치) 형태의 간선 리스트
edges_info = [
    (1, 2, 6),
    (1, 3, 7),
    (2, 4, 5),
    (3, 2, -3),  # 음수 가중치
    (3, 4, 1),
    (4, 5, -2),  # 음수 가중치
]

# 벨만-포드 알고리즘 실행
shortest_distances = bellman_ford(V, edges_info, start)

# --- 결과 출력 ---
# 음수 사이클이 있는 경우와 없는 경우를 모두 처리
if shortest_distances is None:
    print("그래프에 음수 사이클이 존재합니다.")
else:
    print(f"--- 1번 노드로부터의 최단 거리 ---")
    for i in range(1, V + 1):
        if shortest_distances[i] == float('inf'):
            print(f"노드 {i}: 도달 불가")
        else:
            print(f"노드 {i}: {shortest_distances[i]}")
```

```
--- 1번 노드로부터의 최단 거리 ---
노드 1: 0
노드 2: 4
노드 3: 7
노드 4: 8
노드 5: 6
```

---

# **2. 플로이드-워셜 (Floyd-Warshall) 알고리즘**

<aside>
💡

그래프의 **'모든 정점 쌍'** 사이의 최단 경로를 한 번에 구하는 알고리즘

</aside>

## **핵심 아이디어: "거쳐 가는 정점"을 기준으로 최단 거리 갱신**

플로이드-워셜은 3중 `for`문을 사용하여 **동적 프로그래밍(DP)** 방식으로 문제를 해결합니다.

> "모든 정점 k에 대하여, i에서 j로 바로 가는 기존의 경로와, k를 거쳐 가는 경로(i → k → j) 중 더 짧은 것을 선택해 거리를 갱신한다."

이 과정을 모든 `k`, 모든 `i`, 모든 `j`에 대해 반복하면, 최종적으로 모든 쌍 사이의 최단 거리를 담은 2차원 리스트가 완성됩니다.

## **코드 구현**

- 동작 원리 이미지

- 동작 과정 이미지

```python
def floyd_warshall(num_vertices, graph_matrix):
    """
    Floyd-Warshall 알고리즘
    """
    # 2차원 거리 리스트를 초기 그래프 정보로 복사
    distance = [row[:] for row in graph_matrix]

    # k: 거쳐가는 노드
    for k in range(1, num_vertices + 1):
        # i: 출발 노드
        for i in range(1, num_vertices + 1):
            # j: 도착 노드
            for j in range(1, num_vertices + 1):
                # i에서 j로 가는 기존 경로보다, k를 거쳐가는 경로가 더 짧으면 갱신
                if distance[i][k] + distance[k][j] < distance[i][j]:
                    distance[i][j] = distance[i][k] + distance[k][j]

    return distance
```

```python
# --- 실행 예시 ---

# 예시 데이터 직접 입력
V = 4
INF = float('inf')

# 1. 그래프 정보를 인접 행렬로 초기화
#    graph[i][j]는 i에서 j로 가는 직접 간선의 가중치를 의미
#    (V+1) x (V+1) 크기로 생성하여 1번 노드부터 사용
graph_matrix = [[INF] * (V + 1) for _ in range(V + 1)]

# 2. 자기 자신으로 가는 경로는 비용이 0
for i in range(1, V + 1):
    graph_matrix[i][i] = 0

# 3. 간선 정보 입력
#    graph_matrix[출발][도착] = 가중치
edges_info = [
    (1, 2, 4),
    (1, 3, 2),
    (2, 3, 3),
    (2, 4, 2),
    (3, 2, 1),
    (3, 4, 4),
    (4, 1, 1),
]

for start_node, end_node, cost in edges_info:
    graph_matrix[start_node][end_node] = cost

# 플로이드-워셜 알고리즘 실행
shortest_distances = floyd_warshall(V, graph_matrix)

# --- 결과 출력 ---
# shortest_distances[i][j]는 i번 노드에서 j번 노드까지의 최단 거리를 의미
print("--- 모든 쌍 최단 경로 결과 ---")
for i in range(1, V + 1):
    for j in range(1, V + 1):
        if shortest_distances[i][j] == INF:
            print("INF", end="\\t")
        else:
            print(shortest_distances[i][j], end="\\t")
    print()
```

```
--- 모든 쌍 최단 경로 결과 ---
0       3       2       5
3       0       3       2
4       1       0       3
1       4       3       0
```

---

# **3. 알고리즘 비교 및 선택 가이드**

| 알고리즘        | **문제 유형**      | **시간 복잡도**            | **음의 가중치** | **언제 선택하는가?**                             |
| ----------- | -------------- | --------------------- | ---------- | ----------------------------------------- |
| **다익스트라**   | 단일 출발 최단 경로    | **$O(ElogV)$** (힙 사용) | **불가**     | **음수 가중치가 없을 때** 가장 빠르고 일반적인 선택지          |
| **벨만-포드**   | 단일 출발 최단 경로    | O(VE)                 | **가능**     | **음수 가중치가 있을 때** 사용. (음수 사이클 판별도 가능)      |
| **플로이드-워셜** | **모든 쌍** 최단 경로 | $O(V^3)$              | **가능**     | **모든 정점 간** 최단 거리를 구해야 하고, 정점 개수(V)가 작을 때 |

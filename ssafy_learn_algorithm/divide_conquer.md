# Divide and Conquer(분할정복)

> 문제를 작은 하위 문제로 나누고(분할) 각각을 해결(정복)한 뒤, 그 결과를 결합(통합)하여 원래 문제를 해결하는 알고리즘 기법



- 대표적인 문제 해결 기법 비교
  
  1. **완전 탐색(Brute Force)**
     - 모든 경우를 나열 & 테스트
     - 구현 난이도가 낮고 확실한 정답 도출
     - 경우의 수가 큰 문제에는 **시간 초과** 위험
  2. **탐욕(Greedy)**
     - 매 순간 **최적**이라고 생각되는 해를 선택
     - 전역적 최적해를 보장하지 못할 수 있음
  3. **분할 정복(Divide and Conquer)**
     - 문제를 더 작은 **하위 문제**로 나누어 해결한 뒤, 결합
     - 예: 병합 정렬, 퀵 정렬
  4. **동적 프로그래밍(DP)**
     - 이전에 계산한 결과(부분 문제)를 **메모**하여 중복 계산 방지
     - 최적화 문제에 자주 사용
  
  > 실제 문제 풀이 시, **완전 탐색으로 정답을 우선 구하고**, 성능 개선(탐욕, DP 등)으로 최적화하는 경우가 많다.

## **1. 분할 정복이란 무엇일까?**

### **개념: CEO의 업무 처리 방식**

거대한 프로젝트를 맡은 CEO를 상상해 봅시다. CEO는 이 큰일을 혼자 전부 처리하지 않습니다.

1. 프로젝트를 여러 팀이 맡을 수 있는 **작은 단위의 업무로 나눕니다 (Divide).**

2. 각 팀은 맡은 업무를 해결합니다. 만약 업무가 여전히 크다면, 팀장이 팀원에게 일을 더 작게 나누어 맡깁니다 **(Conquer).**

3. 모든 팀원이 각자의 결과물을 완성하면, 팀장은 이를 취합하고, CEO는 최종적으로 모든 팀의 결과물을 모아 **거대한 프로젝트를 완성합니다 (Combine).**
- `분할 정복(Divide and Conquer)`은 이처럼, 혼자 해결하기 어려운 **복잡한 문제를 여러 개의 작은 문제로 나눈 뒤**, 각각을 해결하고 그 결과를 다시 합쳐 원래의 문제를 해결하는 강력한 알고리즘 설계 기법입니다.

---

## **2. 분할 정복의 3단계 과정**

분할 정복은 일반적으로 아래 세 가지 단계를 `재귀`적으로 따릅니다.

### **1단계: 분할 (Divide)**

해결하려는 원래 문제를, **더 이상 나눌 수 없을 때까지** 의미 있는 여러 개의 작은 하위 문제로 나눕니다.

- **(예시)** 1000장의 시험지를 정렬해야 할 때, 먼저 500장씩 두 묶음으로 나눕니다.

### **2단계: 정복 (Conquer)**

나누어진 각 하위 문제를 해결합니다. 만약 하위 문제가 여전히 크다면, 이 문제가 아주 작아져 **곧바로 해결 가능한 수준**이 될 때까지 다시 1단계 분할부터 재귀적으로 반복합니다.

- **(예시)** 500장 묶음을 계속 나누다 보면, 결국 시험지가 **'한 장'**만 남게 됩니다. 시험지 한 장은 그 자체로 이미 정렬된 상태이므로, '정복'이 완료된 것입니다. (이것이 재귀의 **기저 조건(Base Case)**이 됩니다.)

### **3단계: 통합 (Combine)**

해결된 하위 문제들의 답을 **다시 하나로 합쳐** 원래 문제의 답을 구합니다.

- **(예시)** 정렬된 시험지 한 장짜리 묶음들을, 두 묶음씩 정렬하며 합칩니다(병합).
  이 과정을 계속 반복하면, 최종적으로 1000장의 시험지 전체가 정렬됩니다.

---

## **분할 정복의 대표 알고리즘**

이러한 분할 정복 철학을 따르는 대표적인 알고리즘은 다음과 같습니다.

- **병합 정렬 (Merge Sort):** 데이터를 절반으로 계속 나누고, 정렬된 작은 부분들을 다시 합쳐 전체를 정렬합니다. (분할 정복의 가장 교과서적인 예시)
- **퀵 정렬 (Quick Sort):** 특정 '기준(pivot)'을 정해, 그보다 작은 값과 큰 값으로 리스트를 나눈 뒤, 각 부분을 재귀적으로 정렬합니다.
- **이진 탐색 (Binary Search):** 정렬된 배열의 '중간'을 확인하여, 탐색 범위를 절반씩 줄여나갑니다. (통합 과정이 없는 특수한 형태)

---

## **장점과 단점**

### **장점**

- **논리적 해결:** 복잡하고 큰 문제를 논리적으로 명확한 작은 단위로 나누어 접근할 수 있다.
- **효율성:** 문제를 나누는 과정에서 전체 문제의 시간 복잡도를 크게 줄일 수 있다. (예: $O(n^2)$ 문제를 $O(n log n)$으로 개선)
- **병렬 처리:** 나누어진 하위 문제들은 서로 독립적이므로, 여러 개의 프로세서(CPU)를 사용한 병렬 처리에 유리하다.

### **단점**

- **재귀 함수 사용:** 주로 재귀 함수로 구현되므로, 함수 호출에 따른 오버헤드가 발생할 수 있으며, 탐색 깊이가 매우 깊어지면 스택 오버플로우가 발생할 수 있다.
- **구현의 복잡성:** 하위 문제의 결과를 다시 합치는 '통합' 과정을 설계하고 구현하는 것이 복잡할 수 있다.

# List, Array

> 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

- 6개의 변수를 사용해야 하는 경우 배열로 바꾸어 사용

## 배열의 필요성

- 프로그램 내에서 여러 개의 변수가 필요할 때
  - 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있습니다.
  - 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언
  - 단순히 다수의 변수 선언을 의미하는 것이 아님
  - 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있습니다.

# 정렬

> 2개 이상의 자료를 `key(특정 기준)`에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열 하는 알고리즘

## 정렬 알고리즘 비교

| 알고리즘   | 평균 수행시간    | 최악 수행시간    | 알고리즘 기법 | 비고                               |
| ------ | ---------- | ---------- | ------- | -------------------------------- |
| 버블 정렬  | O(n²)      | O(n²)      | 비교와 교환  | 코딩이 가장 손쉽다.                      |
| 카운팅 정렬 | O(n + k)   | O(n + k)   | 비교환 방식  | n이 비교적 작을 때만 가능하다.               |
| 선택 정렬  | O(n²)      | O(n²)      | 교환과 비교  | 교환의 횟수가 버블, 삽입정렬보다 작다.           |
| 퀵 정렬   | O(n log n) | O(n²)      | 분할 정복   | 최악의 경우 O(n²) 이지만, 평균적으로는 가장 빠르다. |
| 삽입 정렬  | O(n²)      | O(n²)      | 비교와 교환  | n의 개수가 작을 때 효과적이다.               |
| 병합 정렬  | O(n log n) | O(n log n) | 분할 정복   | 연결리스트의 경우 가장 효율적인 방식             |

## 버블 정렬

> 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식

### 버블 정렬 과정

1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다

2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다

3. 가장 큰 원소가 정렬 됐으니, 나머지 자리도 반복하여 정렬한다

4. 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다

~~선택 정렬과 헷갈리지 말것~~

#### 시간 복잡도

- O(n^2)

### Code

```python
def bubble_sort(a, N):                  # 정렬할 List, N: 원소 수
    for i in range(N-1, 0, -1):         # 범위의 끝 위치
        for j in range(i):             # 비교할 왼쪽 원소 인덱스 j
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

> 하나씩 칸을 줄이는 걸 range(N-1,0,-1)로 표현!!
> 
> 그리고 자리 바꾸는 걸 python에서는 `a[j], a[j+1] = a[j+1], a[j]` 할당을 사용,, 이건 좀 익숙해져야 할 듯

## 카운팅 정렬(Counting Sort)

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식

#### 제한 사항

1. 카운트를 위한 충분한 공간 할당을 위해 집합 내 가장 큰 정수를 알아야한다

#### 시간복잡도

- O(n+k) : n = len(list), k = max(정수)

## 카운팅 정렬 순서

1. **입력 배열에서 최댓값과 최솟값을 확인**
   
   - 범위가 큰 경우 공간 복잡도가 증가하므로 작은 범위에 적합함.

2. **카운트 배열 생성**
   
   - 입력 배열의 각 요소 값을 인덱스로 하여 등장 횟수를 기록하는 배열을 생성함.

3. **누적합 배열로 변환**
   
   - 각 위치의 값을 이전 위치들과 누적하여 정렬된 위치를 계산할 수 있게 함.

4. **정렬된 결과 배열 생성**
   
   - 입력 배열을 뒤에서부터 순회하며, 누적합 배열을 이용해 정렬된 위치에 값을 배치.

5. **결과 반환**
   
   - 정렬된 결과 배열을 반환하거나, 원래 배열에 복사함.

```python
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)

    # 1. 카운트
    for num in arr:
        count[num] += 1

    # 2. 누적합
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # 3. 결과 배열
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num] - 1] = num
        count[num] -= 1

    return output

# 예시
print(counting_sort([4, 2, 2, 1, 3]))  # [1, 2, 2, 3, 4]
```

> 누적합에서 카운트를 줄이면서 인덱싱으로 제자리를 정렬하는 방식이 매우매우매우 참신하게 다가왔다,,, 어떻게 생각했지 ㄷㄷ 대단하다

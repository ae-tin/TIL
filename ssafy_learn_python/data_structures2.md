# Data Structures

> 비시퀀스 데이터 구조 `딕셔너리`, `세트`

## Dictionary Methods

| 메서드                | 설명                                              |
| ------------------ | ----------------------------------------------- |
| D.get(k)           | 키 k에 연결된 값을 반환 (키가 없으면 None을 반환)                |
| D.get(k, v)        | 키 k에 연결된 값을 반환하거나 키가 없으면 기본 값 v를 반환             |
| D.keys()           | 딕셔너리 D의 키를 모은 객체를 반환                            |
| D.values()         | 딕셔너리 D의 값을 모은 객체를 반환                            |
| D.items()          | 딕셔너리 D의 키/값 쌍을 모은 객체를 반환                        |
| D.pop(k)           | 딕셔너리 D에서 키 k를 제거하고 연결된 값을 반환 (없으면 오류)           |
| D.pop(k, v)        | 딕셔너리 D에서 키 k를 제거하고 연결된 값을 반환 (없으면 v를 반환)        |
| D.clear()          | 딕셔너리 D의 모든 키/값 쌍을 제거                            |
| D.setdefault(k)    | 딕셔너리 D에서 키 k와 연결된 값을 반환                         |
| D.setdefault(k, v) | 키 k가 없으면 값 v와 연결된 키를 D에 추가하고 v를 반환              |
| D.update({other})  | other 딕셔너리에 있는 키에 대해 D에 있는 값을 대체, 없으면 키/값 쌍을 추가 |

> `D.keys()`  --> `dict_keys([key1, key2,,,,])`를 반환하는데, 이것은 실시간으로 key를 동기화 한다!! 객체A에 할당 해놓고 D 딕셔너리에 key를 계속 추가하면 A에 새롭게 D.keys()로 할당 안해도 실시간 업데이트가 됨



> `D.values()` --> `dict_values([value1, value2,,,,])`를 반환하고 `dict_keys([])`와 마찬가지로 동기화 됨!!



> `D.items()` --> `dict_items([(k1, v1), (k2, v2),,,,,])`를 마찬가지로 계속 동기화 시킨다~!



> `D.setdefault(key[, default])` --> `.get(k[, default])` 에 추가 기능이 있는 것과 마찬가지 !! 조건문을 좀 줄일 수 있다 **<<<중요>>>** 



> `D.update({other})` --> other 딕셔너리가 제공하는 key/value 쌍 중 key가 존재하면 other의 value로 갱신하고 key가 없으면 추가함 
> 
> `D.update(key1=value, key2=value2)` 형식으로도 실행 가능함





## Set Methods

- 고유한 항목들의 정렬되지 않은 컬렉션

- Set은 내부적으로 해시 테이블을 사용해서 데이터를 저장

- 항목의 고유성을 효율적으로 보장, 데이터 크기에 관계없이 매우 빠르다

- 합, 교, 차집합 등의 수학적 집합 연산을 간편하게 수행할 수 있다

| 메서드                | 설명                                   |
| ------------------ | ------------------------------------ |
| s.add(x)           | 집합 s에 항목 x를 추가 (이미 x가 있다면 변화 없음)     |
| s.update(iterable) | 집합 s에 다른 iterable 요소들을 추가            |
| s.clear()          | 집합 s의 모든 항목을 제거                      |
| s.remove(x)        | 집합 s에서 항목 x를 제거 (x가 없으면 KeyError 발생) |
| s.pop()            | 집합 s에서 임의의 항목을 반환하고 해당 항목을 제거        |
| s.discard(x)       | 집합 s에서 항목 x를 제거 (x가 없어도 오류 발생하지 않음)  |

> `s.update()` --> 안에 iterable 인거 주의하기



> `s.pop()` --> 임의의 항목을 반환하는 거긴 한데 완전 랜덤 반환이 아닌듯? 



> `s.discard(a)` --> remove와 달리 a가 없어도 오류가 발생하지 않는 거  





| 메서드                             | 설명                                              | 연산자             |
| ------------------------------- | ----------------------------------------------- | --------------- |
| set1.difference(set2)           | set1 - set2: set1에서 set2에 없는 요소만으로 set를 생성 후 반환 | `set1 - set2`   |
| set1.intersection(set2)         | 교집합: set1과 set2에 공통으로 포함된 요소 추출                 | `set1 & set2`   |
| set1.issubset(set2)             | 부분집합 여부: set1이 set2의 부분집합인지 확인                  | `set1 <= set2`` |
| set1.symmetric_difference(set2) | 대칭 차집합 (양쪽에만 있는 요소)                             | `set1 ^ set2`   |
| set1.issuperset(set2)           | 상위집합 여부: set1이 set2를 모두 포함하는지 확인                | ``set1 >= set2` |
| set1.union(set2)                | 합집합: set1과 set2의 모든 요소를 중복 없이 합친 결과             | ``set1 \| set2` |



### Hash Table(해시테이블)

> Key와 Value를 짝지어 저장하는 자료구조



#### 해시 테이블의 원리

1. 키를 해시 함수를 통해 해시 값으로 변환

2. 변환된 해시 값을 인덱스로 삼아 데이터를 저장하거나 찾음

3. 이로 인해 검색, 삽입, 삭제를 매우 빠르게 수행



#### 해시

> 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것

- 생성된 해시 값(고유한 정수)은 해당 데이터를 식별하는 '지문'역할을 함

- 파이썬에서는 이 해시 값을 이용해 해시 테이블에 데이터를 저장

- 이  변환을 수행하는 것이 해시 함수

#### 해시 함수(해시 알고리즘)

> 임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해 주는 함수. 이 정수가 바로 해시 값





### set의 요소 & dict의 키와 해시 테이블 관계

#### set

- 각 요소를 해시 함수로 변환해 나온 해시 값에 맞춰 해시 테이블 내부 버킷(bucket)에 위치시킴
- 그래서 “순서” 라기보다 “버킷 위치(인덱스)”가 요소의 위치를 결정
- 따라서 set는 순서를 보장하지 않음

#### dict

- 키(key) → 해시 함수 → 해시 값 → 해시 테이블에 저장
- 단 set와 달리 “삽입 순서”는 유지한다는 것이 언어 사양에 따라 보장 됨 (python 3.7 이상)
  ▪ 즉, 키를 추가한 순서대로 반복문 순회할 때 나오게 됨
  ▪ 사용자에게 보여지는 키 순서는 삽입 순서가 유지되도록 설계된 것



### 파이썬에서의 해시 함수

#### 정수

- 같은 정수는 항상 같은 해시 값을 가짐
- 예) hash(1)은 여러 번 호출해도 결과가 동일

#### 문자열

- 문자열 해시 시, 파이썬 인터프리터 시작 때 설정되는 난수 시드(seed)가 달라질 수 있음
- 보안상 이유로 해시 난수화 도입
- 각 실행마다 달라질 수 있어 'a'의 해시 값도 매번 바뀔 수 있음


`print(hash(1))      # 1`
`print(hash(1))      # 1`
`print(hash('a'))    # 실행시마다 다름`
`print(hash('a'))    # 실행시마다 다름`



### set의 요소 & dict의 키와 해시테이블 관계

- set의 pop()은 “임의의 요소”를 제거하고 반환함
  
  - 실행할 때마다 다른 요소를 만든다는 의미에서의 “무작위”가 아니라  
    “임의”라는 의미에서의 “무작위” (By "arbitrary" the docs don’t mean “random”)

- 내부적으로 해시 테이블(버킷)을 참조하기 때문에, 실행 때마다 다른 요소가 먼저 나올 수 있음
  
  - 해시 난수화로 인해 문자열 같은 해시 값이 실행마다 달라질 수 있고,  
    따라서 set 내부 요소의 배치가 달라질 수 있음
  
  - 정수는 해시 값이 항상 동일하기 때문에, 파이썬을 동일 프로세스에서 연속 실행할 때는 결과가 어느 정도 일정해 보이기도 하지만,  
    여전히 set은 순서가 없으므로 pop되는 순서는 예측 불가능



### hashable

- hash() 함수에 넣어 해시 값을 구할 수 있는 객체를 의미

- 대부분의 불변 타입은 해시 가능
  
  - 예: int, float, str, tuple (단, 내부에 불변만 있을 경우)

- 가변형 객체(예: list, dict, set)는 기본적으로 해시 불가능
  
  - 이유: 값이 변하면 해시 값도 달라질 수 있어 해시 테이블 무결성이 깨짐

예제 코드:
`print(hash(1))`
`print(hash(1.0))`
`print(hash('1'))`
`print(hash((1, 2, 3)))`

##### TypeError: unhashable type: 'list'

`print(hash((1, 2, [3, 4])))`



## 해시 테이블 정리

- 해시 테이블은 해시 값을 인덱스로 삼아 데이터를 저장, 검색

- 파이썬의 set은 순서가 없고, pop() 시 어떤 요소가 반환될지 정해져 있지 않음

- dict은 파이썬 3.7+ 버전에서 삽입 순서가 보장되지만, 내부 구현은 여전히 해시 테이블

- 해시 함수는 정수/문자열 등 타입에 따라 다르게 동작하며, 문자열 해시 시 난수화로 실행마다 달라질 수 있음

- hashable(해시가 가능한 객체) 객체만 set과 dict의 키로 사용 가능하며, 일반적으로 불변 타입이 이에 해당





















# ORM with view



## HTTP request methods



### GET

- 리소스 조회
  
  - URL에 데이터 노출됨
  
  - 캐싱 가능 : 자주 사용하는 데이터나 결과를 임시로 저장해두고 재활용

- 검색 쿼리 전송, 웹 페이지 요청, API에서 데이터 조회 하는 등에 사용
1. 데이터 전송(url 노출)--> url의 한계가 있기 때문에 2

2. 데이터 제한
   
   1. 대량의 데이터 전송에는 적합하지 않음

3. 브라우저 히스토리
   
   1. 요청 url이 브라우저 히스토리에 남음

4. 캐싱
   
   1. 브라우저는 get요청의 응답을 로컬에 저장할 수 있음
   
   2. 

### POST

- 데이터 생성/전송
  
  - 요청 본문에 데이터
  
  - url 노출 없음
  
  - 서버에 데이터를 제출하여 리소스를 변경(생성, 수정, 삭제) 하는 데 사용
  
  - **CSRF token 필요**
1. 데이터 전송
   
   1. http body를 통해 데이터를 전송

2. 데이터 제한
   
   1. get에 비해 더 많은 양의 데이터를 전송

3. 브라우저 히스토리
   
   1. post요청은 브라우저 히스토리에 남지 않음

4. 캐싱
   
   1. post요청은 캐시 할 수 없음
   
   2. post 요청이 일반적으로 서버 상태를 변경하는 작업을 수행하기 때문





## HTTP response status code

> 서버가 클라이언트 요청에 대한 처리 결과를 나타내는 3자리 숫자

#### 403 Forbidden

- 서버에 요청이 전달되었지만, 권한 때문에 거절되었다는 것을 의미

###### CSRF

> 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행동을 특정 웹사이트에 요청하게 만드는 해킹 방식

- CSRF token이 누락되었다
  
  1. 신뢰할 수 있는 관계 (로그인)
  
  2. 악성 위임장(악성 링크)
  
  3. 나도 모르는 날인(요청 전송)
  
  4. 은행의 착각(공격 성공)

> Django는 CSRF 토큰이라는 안전장치를 사용
> 
> 중요한 요청에 대해 일회용 비밀 코드를 함께 보내도록 하는 것



###### CSRF Token 적용

- DTL의 csrf_token 태그를 사용해서 손쉽게 토큰 값을 부여

- 요청시 토큰 값도 함께 서버로 전송될 수 있도록 하는 것

action method가 POST일때 `{% csrf_token %}` 을 함께 작성


## redirect

- 게시글 저장(Create) 후 페이지를 응답하는 것은 POST요청에 대한 적절한 응답이 아님
- 이는 후속행동(새로고침, 뒤로가기)에서 예기치 않은 동작을 유발할 수 있음
- POST 요청은 동일 요청이 반복되면 안됨
- 사용자가 완료 페이지에서 새로고침 시 중복 게시물 작성의 위험이 있음
- 작성 완료 후 완료 페이지를 직접 응답하는 것은 직관적이지 않고, 사용자의 예상과 다름
- 브라우저 페이지 기록 관리와 상태 관리에 혼란을 줄 수 있음

> ### 서버는 데이터 저장 후 페이지를 응답하는 것이 아닌 사용자를 적절한 기존 페이지로 보내야 한다

- 사용자를 보낸다 -> 사용자가 get 요청을 한 번 더 보내도록 해야 한다.
- 서버가 클라이언트를 직접 다른 페이지로 보내는 것이 아닌 클라이언트가 get 요청을 한 번 더 보내도록 응답하는 것


`def create(request):`
`return redirect('articles:detail', article.pk)`

1. redirect 응답을 받은 클라이언트는 detail url로 다시 요청을 보내게 됨
2. 결과적으로 detail view 함수가 호출되어 detail view 함수의 반환 결과인 detail 페이지를 응답 받게 되는 것

> 결국 사용자는 게시글 작성 후 작성된 게시글의 detail 페이지로 이동하는 것으로 느끼게 됨



















